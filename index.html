<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>hyperobject_mattia_jaroslav</title>
    <link href="https://fonts.googleapis.com/css2?family=Fragment+Mono&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background: #000; overflow: hidden; cursor: none; font-family: 'Fragment Mono', monospace; }
        
        /* Floating labels near mouse */
        #label-stack {
            position: fixed;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10000;
        }

        .label-item {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            padding: 4px 10px;
            border-left: 3px solid;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(2px);
            transition: all 0.2s ease;
        }

        /* RIGHT SIDEBAR: Diagnostic descriptions */
        #desc-sidebar {
            position: fixed;
            top: 40px;
            right: 40px;
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            pointer-events: none;
            z-index: 9999;
        }

        .desc-item {
            border-top: 1px solid #ffffff;
            padding-top: 10px;
            font-size: 11px; 
            line-height: 1.5;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
        }

        .desc-title { font-weight: bold; margin-bottom: 5px; font-size: 13px; }

        /* LEFT METADATA BLOCK: HYPEROBJECT */
        #hyperobject-meta {
            position: absolute;
            top: 40px;
            left: 40px;
            color: #ffffff;
            pointer-events: none;
            z-index: 9999;
            text-transform: uppercase;
            letter-spacing: 02px;
        }

        .meta-title { font-size: 24px; font-weight: bold; margin-bottom: 8px; letter-spacing: 4px; }
        .meta-sub { font-size: 11px; line-height: 1.4; opacity: 0.8; }

        #ui { position: absolute; bottom: 20px; left: 20px; color: rgba(255, 255, 255, 0.2); font-size: 8px; pointer-events: none; letter-spacing: 1px;}
    </style>
</head>
<body>
    <div id="label-stack"></div>
    <div id="desc-sidebar"></div>
    
    <div id="hyperobject-meta">
        <div class="meta-title">HYPEROBJECT</div>
        <div class="meta-sub">
            MATTIA GALBUSERA, JAROSLAV HERRERA<br>
            2GBX - SS26 - PROGRAM DIAGRAM
        </div>
    </div>

    <div id="ui">DIAGNOSTIC_MODE // LENS: 50mm // ANIMATION: RESTORED</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- 1. PARAMETERS (Your custom settings preserved) ---
        const PARAMS = {
            fov: 35, geoScale: 1.5, pointSize: 0.2, wireOpacity: 0.01,
            noiseRadius: 6.5, amplitude: 1.7, velocity: 1.2, period: 1.0, harmonic: 1.6,
            bloomPower: 0.1, bloomRadius: 1.0, mouseBloomPower: 30.0, mouseInfluence: 10.0, bloomFalloff: 5.0,
            rotationSpeed: 0.003, cursorSize: 0.15
        };

        // --- 2. FUNCTION MAP (Labels preserved with added descriptions) ---
        const FUNCTION_MAP = [
            { r: 1.0, g: 0.1427, b: 0.0, label: "CIRCULATION", desc: "Primary transit arteries connecting core structural nodes with high-volume research sectors." },
            { r: 0.5, g: 0.0, b: 0.5, label: "RESEARCH MODULES", desc: "Specialized laboratories for quantum biological studies and planetary transition simulation." },
            { r: 1.0, g: 1.0, b: 1.0, label: "THE ROCK_SHELL", desc: "Reinforced protective plating designed to sustain internal pressure against vacuum exposure." },
            { r: 0.0, g: 0.6, b: 1.0, label: "SYNTETICH LANDSCAPE_EXHIBITION", desc: "Artificial bio-domes preserving Terran botanical DNA for future Martian colonization." },
            { r: 0.0, g: 1.0, b: 0.39, label: "DATA_CENTER", desc: "Centralized processing hub for bridge-wide stability monitoring and inter-planetary data sync." },
            { r: 0.92, g: 0.0, b: 1.0, label: "IMMERSIVE_EXHIBITION", desc: "Virtual sensory modules documenting the cosmological bridge history and Earth-Mars trajectories." },
            { r: 1.0, g: 0.88, b: 0.0, label: "PUBLIC_SPACES", desc: "Social interaction nodes facilitating personnel well-being during long-term bridge residence." },
            { r: 1.0, g: 0.4, b: 0.0, label: "SERVICES_FOOD AREA", desc: "Automated nutrient processing and distribution sector for bridge staff and visitors." },
            { r: 1.0, g: 0.73, b: 0.8, label: "EXHIBITION_SPACES", desc: "Galleries showcasing Martian architectural artifacts and bridge evolution data." }
        ];

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(PARAMS.fov, window.innerWidth / window.innerHeight, 0.1, 3000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), PARAMS.bloomPower, 0.4, 0.1);
        composer.addPass(bloomPass);
        composer.addPass(new OutputPass());

        const mouse2D = new THREE.Vector2(-999, -999);
        const mouse3D = new THREE.Vector3();
        const raycaster = new THREE.Raycaster();
        raycaster.params.Points.threshold = 0.3;

        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        let bridgeGroup = new THREE.Group();
        scene.add(bridgeGroup);

        const stackDiv = document.getElementById('label-stack');
        const sidebarDiv = document.getElementById('desc-sidebar');
        const lineGroup = new THREE.Group();
        scene.add(lineGroup);

        const cursorDot = new THREE.Mesh(
            new THREE.SphereGeometry(PARAMS.cursorSize, 16, 16),
            new THREE.MeshBasicMaterial({ color: new THREE.Color(20.0, 0, 0) }) 
        );
        scene.add(cursorDot);

        window.addEventListener('mousemove', (e) => {
            mouse2D.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse2D.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse2D, camera);
            raycaster.ray.intersectPlane(plane, mouse3D);
            cursorDot.position.copy(mouse3D);

            if (bridgeGroup.children.length > 0) {
                const intersects = raycaster.intersectObjects([bridgeGroup.children[0]], true);
                
                stackDiv.innerHTML = '';
                sidebarDiv.innerHTML = '';
                while(lineGroup.children.length > 0) { 
                    lineGroup.children[0].geometry.dispose();
                    lineGroup.remove(lineGroup.children[0]); 
                }

                if (intersects.length > 0) {
                    const seenColors = new Set();
                    stackDiv.style.left = (e.clientX + 35) + 'px';
                    stackDiv.style.top = (e.clientY - 10) + 'px';

                    intersects.forEach(hit => {
                        const idx = hit.index;
                        const colors = bridgeGroup.children[0].geometry.attributes.color;
                        const r = colors.getX(idx), g = colors.getY(idx), b = colors.getZ(idx);
                        const colorKey = `${r.toFixed(2)},${g.toFixed(2)},${b.toFixed(2)}`;

                        if (!seenColors.has(colorKey)) {
                            seenColors.add(colorKey);
                            const match = FUNCTION_MAP.find(f => Math.abs(f.r - r) < 0.15 && Math.abs(f.g - g) < 0.15 && Math.abs(f.b - b) < 0.15);
                            if (match) {
                                const cssColor = `rgb(${r*255}, ${g*255}, ${b*255})`;
                                
                                // Floating label
                                const item = document.createElement('div');
                                item.className = 'label-item';
                                item.style.color = cssColor;
                                item.style.borderColor = cssColor;
                                item.innerText = match.label;
                                stackDiv.appendChild(item);

                                // Sidebar description
                                const descWrap = document.createElement('div');
                                descWrap.className = 'desc-item';
                                descWrap.style.color = cssColor;
                                descWrap.style.borderColor = cssColor;
                                descWrap.innerHTML = `<div class="desc-title">${match.label}</div>${match.desc}`;
                                sidebarDiv.appendChild(descWrap);

                                const lGeom = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute([hit.point.x, hit.point.y, hit.point.z, mouse3D.x, mouse3D.y, mouse3D.z], 3));
                                const lMat = new THREE.LineBasicMaterial({ color: new THREE.Color(r, g, b), transparent: true, opacity: 0.3 });
                                lineGroup.add(new THREE.Line(lGeom, lMat));
                            }
                        }
                    });
                }
            }
        });

        const vertexShader = `
            attribute vec3 color;
            varying vec3 vColor;
            varying float vGlow;
            uniform float uTime, uVelocity, uPeriod, uHarmonic, uAmplitude, uRadius, uPointSize;
            uniform vec3 uMouse;
            uniform float uMouseInfluence, uBloomFalloff;

            void main() {
                vColor = color;
                vec3 pos = position;
                float d = distance(pos, uMouse);
                if (d < uRadius) {
                    float f = pow(1.0 - (d / uRadius), 2.5);
                    float t = uTime * uVelocity;
                    vec3 b = vec3(sin(pos.y * uPeriod + t), sin(pos.z * uPeriod + t), sin(pos.x * uPeriod + t));
                    vec3 h = vec3(sin(pos.y * (uPeriod * 3.0) + t * 2.0), sin(pos.z * (uPeriod * 3.0) + t * 2.0), 0.0);
                    pos += (b + h * uHarmonic) * uAmplitude * f;
                }
                float bd = distance(pos, uMouse);
                vGlow = (bd < uMouseInfluence) ? pow(1.0 - (bd / uMouseInfluence), uBloomFalloff) : 0.0;
                vec4 mvPos = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = uPointSize * (300.0 / -mvPos.z);
                gl_Position = projectionMatrix * mvPos;
            }
        `;

        const fragmentShader = `
            varying vec3 vColor;
            varying float vGlow;
            uniform bool uIsLine;
            uniform float uOpacity, uMouseBloomPower;
            void main() {
                if (!uIsLine && length(gl_PointCoord - vec2(0.5)) > 0.5) discard;
                vec3 finalColor = vColor * (1.0 + vGlow * uMouseBloomPower);
                gl_FragColor = vec4(finalColor, uIsLine ? uOpacity : 1.0);
            }
        `;

        async function init() {
            try {
                const response = await fetch('MESH-TEST-TD-PROGRAM-4.obj');
                const text = await response.text();
                const pos = [], col = [], ind = [];
                text.split('\n').forEach(line => {
                    const p = line.trim().split(/\s+/);
                    if (p[0] === 'v') {
                        pos.push(parseFloat(p[1]), parseFloat(p[2]), parseFloat(p[3]));
                        col.push(p.length >= 7 ? parseFloat(p[4]) : 1, p.length >= 7 ? parseFloat(p[5]) : 1, p.length >= 7 ? parseFloat(p[6]) : 1);
                    } else if (p[0] === 'f') {
                        const v = [parseInt(p[1])-1, parseInt(p[2])-1, parseInt(p[3])-1];
                        ind.push(v[0],v[1], v[1],v[2], v[2],v[0]);
                    }
                });

                const geom = new THREE.BufferGeometry();
                geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                geom.setAttribute('color', new THREE.Float32BufferAttribute(col, 3));
                geom.setIndex(ind);
                geom.center();
                geom.scale(PARAMS.geoScale, PARAMS.geoScale, PARAMS.geoScale);

                const sharedUniforms = {
                    uTime: { value: 0 }, uMouse: { value: new THREE.Vector3() },
                    uRadius: { value: PARAMS.noiseRadius }, uAmplitude: { value: PARAMS.amplitude },
                    uVelocity: { value: PARAMS.velocity }, uPeriod: { value: PARAMS.period },
                    uHarmonic: { value: PARAMS.harmonic }, uPointSize: { value: PARAMS.pointSize },
                    uOpacity: { value: PARAMS.wireOpacity }, uIsLine: { value: false },
                    uMouseBloomPower: { value: PARAMS.mouseBloomPower },
                    uMouseInfluence: { value: PARAMS.mouseInfluence },
                    uBloomFalloff: { value: PARAMS.bloomFalloff }
                };

                bridgeGroup.add(new THREE.Points(geom, new THREE.ShaderMaterial({ uniforms: THREE.UniformsUtils.clone(sharedUniforms), vertexShader, fragmentShader, transparent: true })));
                const lMat = new THREE.ShaderMaterial({ uniforms: THREE.UniformsUtils.clone(sharedUniforms), vertexShader, fragmentShader, transparent: true });
                lMat.uniforms.uIsLine.value = true;
                lMat.uniforms.uOpacity.value = PARAMS.wireOpacity;
                bridgeGroup.add(new THREE.LineSegments(geom, lMat));

                geom.computeBoundingSphere();
                camera.position.z = geom.boundingSphere.radius * 2.8;
            } catch (err) { console.error(err); }
        }

        function animate(time) {
            requestAnimationFrame(animate);
            bridgeGroup.rotation.y += PARAMS.rotationSpeed;
            const t = time * 0.001;
            const localM = mouse3D.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), -bridgeGroup.rotation.y);
            bridgeGroup.children.forEach(c => {
                if (c.material.uniforms) {
                    c.material.uniforms.uTime.value = t;
                    c.material.uniforms.uMouse.value.copy(localM);
                }
            });
            composer.render();
        }

        init();
        animate();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>